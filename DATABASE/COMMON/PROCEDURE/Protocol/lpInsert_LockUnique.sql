-- Такая "кривая" проверка уникальности, т.к. иногда транзакции не видят друг друга

DROP FUNCTION IF EXISTS lpInsert_LockUnique (TVarChar, Integer);

CREATE OR REPLACE FUNCTION lpInsert_LockUnique(
    IN inKeyData      TVarChar,
    IN inUserId       Integer
)
RETURNS VOID
AS
$BODY$
BEGIN

     -- Проверка
     IF TRIM (COALESCE (inKeyData, '' )) = ''
     THEN 
         RAISE EXCEPTION 'Ошибка.Значение КЛЮЧ в проверке УНИКАЛЬНОСТИ - ПУСТОЙ. <%>', inKeyData;
     END IF;

 
     -- Удаление того что вчера
     DELETE FROM LockUnique WHERE OperDate < CURRENT_DATE; -- - INTERVAL '1 DAY';


     -- Если запись вставится - значит Уникальность соблюдается
     INSERT INTO LockUnique (KeyData, UserId, OperDate)
                     VALUES (inKeyData, inUserId, CURRENT_TIMESTAMP);
   
     EXCEPTION
              WHEN OTHERS THEN RAISE EXCEPTION 'Ошибка.Попытка сформировать повторные данные.Повторите действие через 1 мин.';

END;           
$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION lpInsert_LockUnique (TVarChar, Integer) OWNER TO postgres;

/*
 ИСТОРИЯ РАЗРАБОТКИ: ДАТА, АВТОР
               Фелонюк И.В.   Кухтин И.В.   Климентьев К.И.   Манько Д.
 12.05.17                                        *
*/

-- тест
-- SELECT * FROM lpInsert_LockUnique (inKeyData:= '123', inUserId:= zfCalc_UserAdmin() :: Integer)
-- SELECT * FROM lpInsert_LockUnique (inKeyData:= '123', inUserId:= zfCalc_UserAdmin() :: Integer)
-- SELECT * FROM LockUnique ORDER BY OperDate DESC
